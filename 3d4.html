<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Neon Quantum Cube</title>
<style>
  html, body {
    margin: 0;
    overflow: hidden;
    background: black;
  }
  #label {
    position: fixed;
    bottom: 20px;
    left: 20px;
    font-family: monospace;
    font-size: 22px;
    color: white;
  }
</style>
</head>

<body>
<a href='index.html'><div id="label">IS ON THE WAY!!</div></a>

<!-- Guaranteed working version -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
/* ============================================================
   SETUP
============================================================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(
  45, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.z = 7;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ============================================================
   COLOR PALETTE — 20+15 SHADES OF BLUE
============================================================ */
function blueShade(t) {
  // Deep neon blues → cyan blues
  return new THREE.Color().setHSL(0.55 + 0.08 * t, 1.0, 0.55 + 0.1 * t);
}

/* ============================================================
   FUNCTION TO CREATE A STACK OF INDEPENDENT ROTATING CUBES
============================================================ */
function createCubeStack(count, baseSize, spacing, zOffset, wobbleScale=0.02) {
  const group = new THREE.Group();

  for (let i = 0; i < count; i++) {
    const t = i / (count - 1);
    const size = baseSize * (1 - t * spacing);

    const geom = new THREE.BoxGeometry(size, size, size);
    const edges = new THREE.EdgesGeometry(geom);

    const mat = new THREE.LineBasicMaterial({
      color: blueShade(t),
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending
    });

    const cube = new THREE.LineSegments(edges, mat);

    // Offset in depth so they form a stack
    cube.position.z = -i * zOffset;

    // Different random rotations for each cube to match the GIF
    cube.userData.rx = (Math.random() * 0.6 + 0.2) * (Math.random() < 0.5 ? -1 : 1);
    cube.userData.ry = (Math.random() * 0.6 + 0.2) * (Math.random() < 0.5 ? -1 : 1);
    cube.userData.rz = (Math.random() * 0.6 + 0.2) * (Math.random() < 0.5 ? -1 : 1);

    cube.userData.wobble = 0.01 + Math.random() * wobbleScale;

    group.add(cube);
  }

  return group;
}

/* ============================================================
   OUTER LAYER (20 rotating cubes)
============================================================ */
const outer = createCubeStack(20, 3.2, 0.04, 0.05, 0.02);
scene.add(outer);

/* ============================================================
   INNER CORE (15 rotating cubes)
============================================================ */
const inner = createCubeStack(15, 1.4, 0.05, 0.04, 0.025);
scene.add(inner);

/* ============================================================
   SOFT NEON GLOW CORE
============================================================ */
const glowGeom = new THREE.PlaneGeometry(1.3, 1.3);
const glowMat = new THREE.MeshBasicMaterial({
  color: 0x33aaff,
  transparent: true,
  opacity: 0.25,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});
const glow = new THREE.Mesh(glowGeom, glowMat);
scene.add(glow);

/* ============================================================
   ANIMATION — SLOWER, MATCH GIF TIMING
============================================================ */
function animate(t) {
  t *= 0.001; // convert ms → seconds

  // Match the GIF speed: slower, hypnotic, pulsing
  const flatten = (Math.sin(t * 0.9) + 1) / 2; // 0 → 1 pattern

  outer.children.forEach((cube, i) => {
    const factor = i * 0.08 + 0.2;

    // Slowed independent cube rotations
    cube.rotation.x = Math.sin(t * cube.userData.rx * 0.5 + factor) * (0.8 * flatten);
    cube.rotation.y = Math.sin(t * cube.userData.ry * 0.5 + factor) * (0.8 * flatten);
    cube.rotation.z = Math.sin(t * cube.userData.rz * 0.5 + factor) * (0.8 * flatten);

    // Wobble
    const wob = 1 + Math.sin(t * 2 + factor) * cube.userData.wobble;
    cube.scale.set(wob, wob, wob);
  });

  inner.children.forEach((cube, i) => {
    const factor = i * 0.12 + 0.5;

    cube.rotation.x = Math.sin(t * cube.userData.rx * 0.6 + factor) * (1.0 * flatten);
    cube.rotation.y = Math.sin(t * cube.userData.ry * 0.6 + factor) * (1.0 * flatten);
    cube.rotation.z = Math.sin(t * cube.userData.rz * 0.6 + factor) * (1.0 * flatten);

    const wob = 1 + Math.sin(t * 2.5 + factor) * cube.userData.wobble;
    cube.scale.set(wob, wob, wob);
  });

  // Glow pulse
  const pulse = 1 + 0.1 * Math.sin(t * 2.2);
  glow.scale.set(pulse, pulse, pulse);

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

/* ============================================================
   RESIZE
============================================================ */
window.addEventListener("resize", () => {
  const w = window.innerWidth;
  const h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
});
</script>

</body>
</html>


